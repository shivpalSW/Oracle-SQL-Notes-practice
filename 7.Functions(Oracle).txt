FUNCTIONS:
---------------------
> TO PERFORM TASK & MUST RETURN VALUE.
> ORACLE SUPPORTS TWO TYPES FUNCTIONS.THOSE ARE

	1) PRE-DEFINE / BUILT IN  FUNCTIONS (USE IN SQL & PL/SQL)
	2) USER DEFINE FUNCTIONS ( USE IN PL/SQL)

1) PRE-DEFINE FUNCTIONS:
---------------------------------------------
> THESE ARE AGAIN CLASSIFIED INTO TWO CATEGORIES.

	A) SINGLE ROW FUNCTIONS (SCALAR FUNCTIONS)
	B) MULTIPLE ROW FUNCTIONS(GROUPING FUNCTIONS)

SINGLE ROW FUNCTIONS:
--------------------------------------------
> THESE FUNCTIONS ARE RETURNS A SINGLE ROW (OR) A SINGLE VALUE.
	
	> NUMERIC FUNCTIONS
	> STRING FUNCTIONS
	> DATE FUNCTIONS
	> CONVERSION FUNCTIONS

HOW TO CALL A FUNCTION:
---------------------------------------------
SYNTAX:
---------------
SELECT <FNAME>(VALUES) FROM DUAL;

WHAT IS DUAL:
------------------------
> PRE-DEFINE TABLE IN ORACLE.
> HAVING SINGLE COLUMN & SINGLE ROW
> IS CALLED AS DUMMY TABLE IN ORACLE.
> TESTING FUNCTIONS(PRE-DEFINE & USER DEFINE) FUNCTIONALITIES. 

TO VIEW STRC.OF DUAL TABLE:
----------------------------------------------------
SQL> DESC DUAL;

TO VIEW DATA OF DUAL TABLE:
----------------------------------------------------
SQL> SELECT  * FROM DUAL;


NUMERIC FUNCTIONS:
--------------------------------------
1) ABS():
> CONVERTS (-ve) VALUE INTO (+ve) VALUE.

SYNTAX:
---------------
	ABS(NUMBER)

EX:
SQL> SELECT ABS(-12) FROM DUAL; --------> 12
SQL> SELECT ENAME,SAL,COMM,ABS(COMM-SAL) FROM EMP;

2) CEIL():
> RETURNS A VALUE WHICH IS GREATER THAN OR EQUAL TO GIVEN VALUE.

SYNTAX:
---------------
	CEIL(NUMBER)

EX:
SQL> SELECT CEIL(9.0) FROM DUAL;------9
SQL> SELECT CEIL(9.3) FROM DUAL;-------10

3) FLOOR():

SYNTAX:
	FLOOR(NUMBER)

EX:
SQL> SELECT FLOOR(9.0) FROM DUAL;------9
SQL> SELECT FLOOR(9.8) FROM DUAL;------9

4) MOD():
RETURNS REMAINDER VALUE.

SYNTAX:
	MOD(m,n)

EX:
SQL> SELECT MOD(10,2) FROM DUAL;-------0

5) POWER():
THE POWER OF GIVEN EXPRESSION

SYNTAX:
	POWER(m,n)

EX:
SQL> SELECT POWER(2,3) FROM DUAL;----------8

ROUND():
> NEAREST VALUE GIVEN EXPRESSION.

SYNTAX:
	ROUND(NUMBER,[DECIMAL PLACES])

EX:
SQL> SELECT ROUND(5.50) FROM DUAL;------6
SQL> SELECT ROUND(32.456,2) FROM DUAL;------32.46

TRUNC:
--------------
> RETURNS A VALUE WHICH WILL SPECIFIED NUMBER OF DECIMAL PLACES.

SYNTAX:
	TRUNC(NUMBER,DECIMAL PLACES)

EX:
SQL> SELECT TRUNC(5.50) FROM DUAL;---------5
SQL> SELECT TRUNC(32.456,2) FROM DUAL;----32.45
==========================================================================
STRING FUNCTIONS:
-----------------------------------
LENGTH():
------------------
> LENGTH OF GIVEN STRING.

SYNTAX:
	LENGTH(STRING)

EX:
SQL> SELECT LENGTH('HELLO') FROM DUAL;------------------------5
SQL> SELECT LENGTH('GOOD MORNING') FROM DUAL;--------12

SQL> SELECT ENAME,LENGTH(ENAME) FROM EMP;
SQL> SELECT * FROM EMP WHERE LENGTH(ENAME)=4;

LOWER():
----------------
TO CONVERT UPPER CASE CHAR's INTO LOWER CASE CHAR's.

SYNTAX:	
	LOWER(STRING)

EX:
SQL> SELECT LOWER('HELLO') FROM DUAL;
SQL> UPDATE EMP SET ENAME=LOWER(ENAME) WHERE JOB='CLERK';

UPPER():
---------------
SYNTAX:
	UPPER(STRING)

EX:
SQL> SELECT UPPER('hello') FROM DUAL;

INITCAP():
------------------
TO CONVERT FIRST CHAR. IS CAPITAL.

SYNTAX:
	INITCAP(STRING)

EX:
SQL> SELECT INITCAP('hello') FROM DUAL;
SQL> SELECT INITCAP('good morning') FROM DUAL;

LTIRM():
---------------
TO REMOVE UNWANTED SPACES (OR) UNWANTED CHARACTERS FROM LEFT SIDE 
OF GIVEN STRING.

SYNTAX:
	LTRIM(STRING1[,STRING2])

EX:
SQL> SELECT LTRIM('    SAI') FROM DUAL;
SQL> SELECT LTRIM('XXXXXXSAI','X') FROM DUAL;
SQL> SELECT LTRIM('123SAI','123') FROM DUAL;

RTRIM():
---------------
TO REMOVE UNWANTED SPACES (OR) UNWANTED CHARACTERS FROM RIGHT SIDE 
OF GIVEN STRING.

SYNTAX:
	RTRIM(STRING1[,STRING2])

EX:
SQL> SELECT RTRIM('SAIXXXXXXX','X') FROM DUAL;

TRIM():
------------
TO REMOVE UNWANTED SPACES (OR) UNWANTED CHARACTERS FROM BOTH SIDES 
OF GIVEN STRING.

SYNTAX:
----------------
	TRIM('TRIMMING CHAR' FROM 'STRING')

EX:
SQL> SELECT TRIM('X' FROM 'XXXXXXSAIXXXX') FROM DUAL;

LPAD():
------------
TO FILL A STRING WITH SPECIFIC CHAR. ON LEFT SIDE OF GIVEN
STRING.

SYNTAX:
---------------
	LPAD(STRING1,LENGTH,STRING2)

EX:
SQL> SELECT LPAD('HELLO',10,'@') FROM DUAL;
@@@@@HELLO

RPAD():
-------------
TO FILL A STRING WITH SPECIFIC CHAR. ON RIGHT SIDE OF GIVEN
STRING.

SYNTAX:
---------------
	RPAD(STRING1,LENGTH,STRING2)

EX:
SQL> SELECT RPAD('HELLO',10,'@') FROM DUAL;
HELLO@@@@@

CONCAT():
-----------------
ADDING TWO STRING EXPRESSIONS.

SYNTAX:
--------------
	CONCAT(STRING1,STRING2)

EX:
SQL> SELECT CONCAT('GOOD','BYE') FROM DUAL;

REPLACE():
-------------------
TO REPLACE ONE STRING WITH ANOTHER STRING.

SYNTAX:
---------------
	REPLACE(STRING1,STRING2,STRING3)

EX:
SQL> SELECT REPLACE('HELLO','ELL','XYZ') FROM DUAL;
HXYZO

SQL> SELECT REPLACE('HELLO','L','ABC') FROM DUAL;
HEABCABCO

TRANSLATE():
------------------------
TO TRANSLATE A SINGLE CHAR WITH ANOTHER SINGLE CHAR.

SYNTAX:
--------------
	TRANSLATE(STRING1,STRING2,STRING3)

EX:
SQL> SELECT TRANSLATE('HELLO','ELO','XYZ') FROM DUAL;
HXYYZ
	SOL:   E = X , L=Y , O=Z
	HELLO => HXYYZ

EX:
SQL> SELECT ENAME,SAL,TRANSLATE(SAL,'0123456789','$b@gH*v#t%') SALARY FROM EMP;

ENAME             SAL 		SALARY
----------	 ---------------		-------------------------
SMITH             800 		t$$
	
	SOL: 0=$,1=b,2=@,3=g,4=H,5=*,6=v,7=#,8=t,9=%.

SUBSTR():
-----------------
IT RETURNS REQ.SUBSTRING FROM GIVEN STRING EXPRESSION.

SYNTAX:
---------------
	SUBSTR(STRING1,<STARTING POSITION OF CHAR.>,<LENGTH OF CHAR's>)

EX:
SQL> SELECT SUBSTR('HELLO',2,3) FROM DUAL;
ELL

SQL> SELECT SUBSTR('WELCOME',4,2) FROM DUAL;
CO

SQL> SELECT SUBSTR('WELCOME',-6,3) FROM DUAL;
ELC

INSTR():
--------------
RETURNS OCCURENCE POSITION OF A CHAR. IN THE GIVEN STRING.

SYNTAX:
---------------
INSTR(STRING1,STRING2,<STARTING POSITION OF CHAR.>,<OCCURENCE POSITION OF CHAR.>)


EX:
SQL> SELECT INSTR('HELLO WELCOME','O') FROM DUAL;---------> 5                  
SQL> SELECT INSTR('HELLO WELCOME','Z') FROM DUAL;-----> 0
SQL> SELECT INSTR('HELLO WELCOME','O',1,2) FROM DUAL;-----11
SQL> SELECT INSTR('HELLO WELCOME','E',5,2) FROM DUAL;-------13
SQL> SELECT INSTR('HELLO WELCOME','E',1,4) FROM DUAL;--------8

NOTE:
----------
POSITION OF CHAR's ALWAYS FIXED EITHER COUNT FROM LEFT TO  RIGHT
(OR) RIGHT TO LEFT.

	SOL: HELLO   WELCOME
	         12345 6 78910111213

EX:
SQL> SELECT INSTR('HELLO WELCOME','E',-1,3) FROM DUAL;--------2
SQL> SELECT INSTR('HELLO WELCOME','L',-4,3) FROM DUAL;-------3
SQL> SELECT INSTR('HELLO WELCOME','L',-6,3) FROM DUAL;----------0
==========================================================================
DATE FUNCTIONS:
------------------------------
1) SYSDATE:
---------------------
> CURRENT DATE INFORMATION OF THE SYSTEM.

EX:
SQL> SELECT SYSDATE FROM DUAL;
SQL> SELECT SYSDATE+10 FROM DUAL;
SQL> SELECT SYSDATE-10 FROM DUAL;

ADD_MONTHS():
--------------------------
> ADDING NO.OF MONTHS TO THE DATE.

SYNTAX:
---------------
	ADD_MONTHS(DATE,<NO.OF MONTHS>)

EX:
SQL> SELECT ADD_MONTHS(SYSDATE,3) FROM DUAL;
SQL> SELECT ADD_MONTHS(SYSDATE,-3) FROM DUAL;

LAST_DAY():
---------------------
> RETURNS THE LAST DAY OF THE MONTH.

SYNTAX:
--------------
	LAST_DAY(DATE)

EX:
SQL> SELECT LAST_DAY(SYSDATE) FROM DUAL;

NEXT_DAY():
--------------------
> RETURNS THE NEXT SPECIFIED DAY FROM THE GIVEN DATE.

SYNTAX:
---------------
	NEXT_DAY(DATE,'<DAY NAME>')

EX:
SQL> SELECT NEXT_DAY(SYSDATE,'SUNDAY') FROM DUAL;

MONTHS_BETWEEN():
------------------------------------
> RETURNS NO.OF MONTHS BETWEEN TWO DATE EXPRESSIONS.

SYNTAX:
---------------
	MONTHS_BETWEEN(DATE1,DATE2)

EX:
SQL> SELECT MONTHS_BETWEEN('05-JAN-81','05-JAN-80') FROM DUAL;----- 12
SQL> SELECT MONTHS_BETWEEN('05-JAN-80','05-JAN-81') FROM DUAL;----- -12

NOTE: HERE, DATE1 IS ALWAYS GREATER THAN DATE2 OTHERWISE
            ORACLE RETURNS NAGATIVE VALUE.
=======================================================================
CONVERSION FUNCTIONS:
-------------------------------------------
	1. TO_CHAR()
	2. TO_DATE()

TO_CHAR():
-------------------
> DATE TYPE TO CHAR TYPE TO DISPLAY DATE IN DIFFERENT FORMAT.

SYNTAX:
	TO_CHAR(DATE,[<FORMAT>])

YEAR FORMATS:
---------------------------
	YYYY	-	2020
	YY	-	20
	YEAR	-	TWENTY TWENTY
	CC	-	CENTUARY 21
	AD / BC	-	AD YAER / BC YEAR
EX:
SQL> SELECT TO_CHAR(SYSDATE,'YYYY  YY  YEAR CC AD') FROM DUAL;

TO_CHAR(SYSDATE,'YYYYYYYEARCCAD')
----------------------------------------------------------
2020  20  TWENTY TWENTY 21 AD

Q: TO DISPLAY EMPLOYEE WHO ARE JOINED IN YEAR 1982
BY USING TO_CHAR() FUNCTION ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')=1982;

Q: TO DISPLAY EMPLOYEE WHO ARE JOINED IN YEAR 1980,1982,1987
BY USING TO_CHAR() FUNCTION ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY') IN(1980,1982,1987);

MONTH FORMAT:
----------------------------
MM	- MONTH NUMBER
MON	- FIRST THREE CHAR FROM MONTH SPELLING
MONTH	- FULL NAME OF MONTH 

EX:
SQL> SELECT TO_CHAR(SYSDATE,'MM MON MONTH') FROM DUAL;

TO_CHAR(SYSDATE,
----------------
08 AUG AUGUST

SQL> SELECT TO_CHAR(SYSDATE,'mm mon month') FROM DUAL;

TO_CHAR(SYSDATE,
----------------
08 aug august

Q: TO DISPLAY EMPLOYEE WHO ARE JOINED IN FEB,MAY,DEC MONTHS
BY USING TO_CHAR() ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'MM') IN(02,05,12);

Q: TO DISPLAY EMPLOYEE WHO ARE JOINED IN FEB 1981 
BY USING TO_CHAR() ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'MMYYYY')='021981';

DAY FORMATS:
-------------------------
DDD	- DAY OF THE YEAR.
DD	- DAY OF THE MONTH.
D	- DAY OF THE WEEK
	SUN 	- 1
	MON 	- 2
	TUE 	- 3
	WEN 	- 4
	THU 	- 5
	FRI 	- 6
	SAT	- 7

DAY	- FULL NAME OF THE DAY 
DY	- FIRST THREE CHAR's OF DAY SPELLING

EX:SQL> SELECT TO_CHAR(SYSDATE,'DDD DD D DAY DY') FROM DUAL;

TO_CHAR(SYSDATE,'DDDDD
----------------------------------------------
220 07 6 FRIDAY    FRI

Q: TO DISPLAY EMPLOYEE WHO ARE JOINED ON "FRIDAY" BY USING
TO_CHAR() ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'DAY')='FRIDAY';

Q: TO DISPLAY EMPLOYEE ON WHICH DAY EMPLOYEES ARE JOINED ?

SOL:
SQL> SELECT ENAME||' '||'JOINED ON'||' '||TO_CHAR(HIREDATE,'DAY') FROM EMP;

NOTE:
----------
IN ORACLE WHENEVER WE USING TO_CHAR() AND ALSO WITHIN TO_CHAR() WHEN WE 
USE DAY / MONTH FORMAT THEN ORACLE SERVER INTERNALLY ALLOCATE SOME EXTRA MEMORY FOR DAY/MONTH FORMAT OF DATA.
	TO OVERCOME THE ABOVE  PROBLEM THAT IS TO REMOVE EXTRA MEMORY WHICH WAS ALLOCATE BY ORACLE SERVER THEN WE USE A PRE-DEFINE SPECIFIER IS 
CALLED "FM" (FILL MODE).

EX:
SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'FMDAY')='FRIDAY';

QUATER FORMAT:
----------------------------
Q	- ONE DIGIT QUATER OF THE YEAR

	1 - JAN - MAR
	2 - APR - JUN
	3 - JUL - SEP
	4 - OCT - DEC

EX:
SQL> SELECT TO_CHAR(SYSDATE,'Q') FROM DUAL;
T
---
3

Q : WHO ARE JOINED IN 2nd QUATER OF 1981 ?

SOL:
SQL> SELECT * FROM EMP WHERE TO_CHAR(HIREDATE,'YYYY')='1981' AND TO_CHAR(HIREDATE,'Q')=2;

WEEK FORMAT:
--------------------------
WW	- WEEK OF THE YEAR
W	- WEEK OF MONTH

EX:
SQL> SELECT TO_CHAR(SYSDATE,'WW W') FROM DUAL;

TO_C
---------
32  2

TIME FORMAT:
-------------------------
HH	- HOUR PART
HH24	- 24 hrs FROMAT
MI	- MINUTE PART
SS	- SECONDS PART
AM / PM 	- AM TME (OR) PM TIME

EX:
SQL> SELECT TO_CHAR(SYSDATE,'HH:MI:SS AM') FROM DUAL;

TO_CHAR(SYS
------------------------
12:04:21 PM

TO_DATE():
------------------
TO CONVERT CHAR TYPE TO ORACLE DATE FORMAT TYPE.

SYNTAX:
	TO_DATE(STRING[,FROMAT])

EX:
SQL> SELECT TO_DATE('08/AUGUST/2020') FROM DUAL;

TO_DATE('
---------
08-AUG-20

SQL> SELECT TO_DATE('08-AUG-2020')+10 FROM DUAL;

TO_DATE('
---------
18-AUG-20

MULTIPLE ROW FUNCTIONS:
-----------------------------------------------
THESE FUNCTIONS ARE RETURNS EITHER GROUP OF VALUES 
(OR) A SINGLE VALUE.

SUM():
-----------
> IT RETURNS SUM OF A SPECIFIC COLUMN VALUES.

EX:
SQL> SELECT SUM(SAL) FROM EMP;
SQL> SELECT SUM(SAL) FROM EMP WHERE JOB='CLERK';

AVG():
----------
> IT RETURNS AVERAGE OF A SPECIFIC COLUMN VALUES.

EX:
SQL> SELECT AVG(SAL) FROM EMP;
SQL> SELECT AVG(SAL) FROM EMP WHERE DEPTNO=10;

MIN():
----------
> IT RETURNS MIN.VALUE FROM GROUP OF VALUES.

EX:
SQL> SELECT MIN(HIREDATE) FROM EMP;
SQL> SELECT MIN(HIREDATE) FROM EMP WHERE JOB='MANAGER';
SQL> SELECT MIN(SAL) FROM EMP;

MAX():
-----------
> IT RETURNS MAX.VALUE FROM GROUP OF VALUES.

EX:
SQL> SELECT MAX(SAL) FROM EMP;

COUNT():
----------------
> IT RETURNS NO.OF ROWS IN A TBALE / NO.OF VALUES IN A COLUMN
> THREE TYPES,
	i) COUNT(*)
	ii) COUNT(<COLUMN NAME>)
	iii) COUNT(DISTINCT <COLUMN NAME>)

EX:
	TEST
	--------
SNO 	NAME
--- 	-----
101 	A
102 	B
103
104 	C
105 	A
106 	C

COUNT(*):
----------------
> COUNTING ALL ROWS (DUPLICATES & NULLS) IN A TABLE.

EX:
SQL> SELECT COUNT(*) FROM TEST;

  COUNT(*)
------------------
         6

COUNT(<COLUMN NAME>):
--------------------------------------------
> COUNTING ALL VALUES INCLUDING DUPLICATE VALUES BUT NOT NULL VALUES 
FROM A COLUMN.

EX:
SQL> SELECT COUNT(NAME) FROM TEST;

COUNT(NAME)
-----------------------
          5

COUNT(DISTINCT <COLUMN NAME>):
--------------------------------------------------------------
> COUNTING UNIQUE VALUES FROM A COLUMN.HERE "DISTINCT" KEYWORD
IS ELIMINATING DUPLICATE VALUES.

EX:
SQL> SELECT COUNT(DISTINCT NAME) FROM TEST;

COUNT(DISTINCTNAME)
---------------------------------------
                  3
