CURSORS:
=========
> CURSOR IS A TEMP.MEMORY / A PRIVATE SQL AREA(PSA) / A WORK SPACE.
> CURSOR ARE TWO TYPES.THOSE ARE:

	i) EXPLICIT CURSOR (USER DEFINE CURSOR)
	ii) IMPLICIT CURSOR (SYSTEM DEFINE CURSOR)

i) EXPLICIT CURSOR:
=================
> THESE CURSOR ARE CREATING BY USER FOR HOLDING MULTIPLE ROWS BUT WE CAN 
ACCESS ONLY ONE ROW AT TIME.(ONE BY ONE / ROW BY ROW MANNER). 
> IF WE WANT TO CREATE AN EXPLICIT CURSOR WE NEED FOLLOW THE FOLLOWING
FOUR STEPS.THOSE ARE
	1) DECLARING A CURSOR
	2) OPEN A CURSOR 
	3) FETCH ROWS FROM A CURSOR
	4) CLOSE A CURSOR 

Steps To Create Explicit Cursor:
===========================
1)Declaring A Cursor:
==================
In this process we define a cursor.

Syntax: 
======
Declare cursor <cursorname> is < select statement>;

2)Opening A Cursor:
==================
When we open a cursor it will internally execute the select statement that is associated with the cursor declartion and load the data into cursor.

Syntax:
======    
Open < cursorname>;	

3)Fetching Data From The Cursor:
============================
In this process we access row by row from cursor.

Syntax:
======
Fetch <cursorname> into <variables>;

4)Closing A Cursor: 
================
In this Process,it releases the current result set of the cursor leaving the datastructure available for reopening.

Syntax:     
======
Close <cursorname>;

ATTRIBUTES OF EXPLICIT CURSORS:
===============================
 It shows status of the cursor and it returns boolean value.

syntax:
======
 <cursor_name>%<attribute>;

a. %isopen:
==========
 It returns true, when the cursor opens successfully.

b. %found:
=========
It returns true, when the cursor contains data.

c. %notfound:
===========
It returns true, when the cursor doesn't find any data.

d.%rowcount:
===========
It returs no.of fetch statements executed.return type is number.

EX1:
WA CURSOR PROGRAM TO FETCH A SINGLE ROW FROM EMP TABLE ?

SOL:
DECLARE CURSOR C1 IS SELECT ENAME,SAL FROM EMP;
v_ENAME VARCHAR2(10);
v_SAL NUMBER(10);
BEGIN
OPEN C1;
FETCH C1 INTO v_ENAME,v_SAL;
DBMS_OUTPUT.PUT_LINE(v_ENAME||','||v_SAL);
CLOSE C1;
END;
/

OUTPUT:
SMITH,800

EX2: TO FETCH MULTIPLE ROWS FROM EMP TABLE BY USING LOOPING STATEMENTS ?

i) BY USING SIMPLE LOOP:
======================
- it is an infinite loop.so that we need break a loop then we are using "EXIT" statement.

SOL:
 DECLARE CURSOR C1 IS SELECT ENAME,SAL FROM EMP;
 v_ENAME VARCHAR2(10);
 v_SAL NUMBER(10);
 BEGIN
 OPEN C1;
 LOOP
 FETCH C1 INTO v_ENAME,v_SAL;
 EXIT WHEN C1%NOTFOUND;
 DBMS_OUTPUT.PUT_LINE(v_ENAME||','||v_SAL);
 END LOOP;
 CLOSE C1;
 END;
 /

OUTPUT:
SMITH,800
ALLEN,1600
WARD,1250
..................
...................

ii) BY USING WHILE LOOP:
======================
 DECLARE CURSOR C1 IS SELECT ENAME,SAL FROM EMP;
 v_ENAME VARCHAR2(10);
 v_SAL NUMBER(10);
 BEGIN
 OPEN C1;
 FETCH C1 INTO v_ENAME,v_SAL;------------LOOP START FROM 1st ROW
 WHILE(C1%FOUND)
 LOOP
 DBMS_OUTPUT.PUT_LINE(v_ENAME||','||v_SAL);
 FETCH C1 INTO v_ENAME,v_SAL;------------LOOP CONTINUE UPTO LAST ROW
 END LOOP;
 CLOSE C1;
 END;
 /

iii) BY USING FOR LOOP:
=====================
DECLARE CURSOR C1 IS SELECT ENAME,SAL FROM EMP;
BEGIN
FOR i IN C1
LOOP
DBMS_OUTPUT.PUT_LINE(i.ENAME||','||i.SAL);
END LOOP;
END;
/

NOTE: WHENEVER WE ARE USING "FOR LOOP" STATEMENT IN CURSOR FOR FETCHING ROWS FROM A CURSOR MEMORY THEN THERE NO NEED TO OPEN CURSOR,FETCH ROW
FROM CURSOR AND CLOSE CURSOR BY EXPLICITLY BECAUSE INTERNALLY ORACLE 
SERVER WILL OPEN,FETCH AND CLOSE CURSOR BY IMPLICITLY.
	HERE, FOR LOOP EXECUTE NO.OF TIMES DEPENDS ON NO.OF ROWS IN CURSOR(C1).EVERY TIME FOR LOOP IS EXECUTE AND FETCH A ROW FROM C1 AND 
ASSIGNED / STORED IN LOOP VARIABLE (i) AND LATER i LOOP VARIABLE VALUES ARE
PRINTED.

EX3: 
WA CURSOR PROGRAM TO FETCH TOP FIVE HIGHEST SALARIES EMPLOYEE
ROWS FROM EMP TABLE?

SOL:
DECLARE CURSOR C1 IS SELECT ENAME,SAL FROM EMP ORDER BY SAL DESC;
v_ENAME VARCHAR2(10);
v_SAL NUMBER(10);
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO v_ENAME,v_SAL;
EXIT WHEN C1%ROWCOUNT>5;
DBMS_OUTPUT.PUT_LINE(v_ENAME||','||v_SAL);
END LOOP;
CLOSE C1;
END;
/

OUTPUT:
========
KING,5000
FORD,3000
SCOTT,3000
JONES,2975
BLAKE,2850

EX4:
WA CURSOR PROGRM TO FETCH EVEN POSITION  ROWS FROM EMP TABLE ?

SOL:
 DECLARE CURSOR C1 IS SELECT EMPNO,ENAME FROM EMP;
 v_EMPNO NUMBER(10);
 v_ENAME VARCHAR2(10);
 BEGIN
 OPEN C1;
 LOOP
 FETCH C1 INTO v_EMPNO,v_ENAME;
 EXIT WHEN C1%NOTFOUND;
 IF MOD(C1%ROWCOUNT,2)=0 THEN
 DBMS_OUTPUT.PUT_LINE(v_EMPNO||','||v_ENAME);
 END IF;
 END LOOP;
 CLOSE C1;
 END;
 /

OUTPUT:
========
7499,ALLEN
7566,JONES
7698,BLAKE
7788,SCOTT
7844,TURNER

EX5: 
WA CURSOR PROGRAM TO FETCH 9th POSITION ROW FROM EMP TABLE?

SOL:
DECLARE CURSOR C1 IS SELECT ENAME FROM EMP;
v_ENAME VARCHAR2(10);
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO v_ENAME;
EXIT WHEN C1%NOTFOUND;
IF C1%ROWCOUNT=9 THEN
DBMS_OUTPUT.PUT_LINE(v_ENAME);
END IF;
END LOOP;
CLOSE C1;
END;
/

OUTPUT:
=======
KING

PARAMETERIZED CURSORS:
========================
	- WHENEVER WE ARE PASSING PARAMETERS TO THE CURSOR AT THE TIME DECLARATION IS CALLED AS PARAMETERIZED CURSOR. THESE PARAMETERIZED CURSOR WANT TO DECLARE THEN WE FOLLOW THE FOLLOWING TWO STEPS ARE

STEP1: DECLARE PARAMETERIZED CURSOR:
======================================
SYNTAX:
--------------
DECLARE CURSOR <CURSOR NAME>(<PARAMETER NAME> <DATATYPE>,........) IS 
SELECT * FROM <TN> WHERE <CONDITION>;

STEP2: OPEN PARAMETERIZED CURSOR:
==================================
SYNTAX:
--------------
OPEN <CURSOR NAME>(<PARAMETER NAME> / <VALUE>);

EX1:
WA CURSOR PROGRAM TO ACCEPT DEPTNO AS A PARAMETER AND DISPLAY THE NO.OF EMPLOYEE WORKING IN THE GIVEN DEPTNO FROM EMP TABLE?

SOL:
DECLARE CURSOR C1(p_DEPTNO NUMBER) IS SELECT ENAME,DEPTNO FROM EMP
WHERE DEPTNO=p_DEPTNO;
v_ENAME VARCHAR2(10);
v_DEPTNO NUMBER(10);
BEGIN
OPEN C1(&p_DEPTNO);
LOOP
FETCH C1 INTO v_ENAME,v_DEPTNO;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(v_ENAME||','||v_DEPTNO);
END LOOP;
CLOSE C1;
END;
/

OUTPUT:
========
Enter value for p_deptno: 10
MILLER,10
CLARK,10
KING,10

EX2:
WA CURSOR PROGRAM TO ACCEPT EMPNO AS A PARAMETER AND CHECK THAT EMPLOYEE IS EXISTS OR NOT EXISTS IN EMP TABLE?

SOL:
DECLARE CURSOR C1(p_EMPNO NUMBER) IS SELECT ENAME FROM EMP
WHERE EMPNO=p_EMPNO;
v_ENAME VARCHAR2(10);
BEGIN
OPEN C1(&p_EMPNO);
FETCH C1 INTO v_ENAME;
IF C1%FOUND THEN
DBMS_OUTPUT.PUT_LINE('EMPLOYEE EXISTS,NAME IS:-'||v_ENAME);
ELSE
DBMS_OUTPUT.PUT_LINE('EMPLOYEE NOT EXISTS');
END IF;
CLOSE C1;
END;
/
OUTPUT:
========
Enter value for p_empno: 7788
EMPLOYEE EXISTS,NAME IS:-SCOTT

IMPLICIT CURSOR:
================
	- THESE CURSOR ARE DECLARING BY ORACLE SERVER BY DEFAULT.ORACLE DECLARE THESE CURSOR AFTER EXECUTION OF DML COMMAND(INSERT / UPDATE / DELETE). 
	- IMPLICIT CURSOR TELLING US THE STATUS OF LAST DML COMMAND WHETHER SUCCESSFULL OR NOT.

ATTRIBUTES OF IMPLICIT CURSORS:
===============================
1. %ISOPEN :
	- IT RETURNS TRUE THEN CURSOR SUCCESSFUL OPEN OTHERWISE RETURNS FALSE.

2. %NOTFOUND:
	- IT RETURNS TRUE THEN LAST DML COMMAND IS FAIL OTHERWISE RETURNS FALSE.

3. %FOUND:
	- IT RETRUNS TRUE THEN LAST DML COMMAND IS SUCCESSFULLY EXECUTED
OTHERWISE RETURNS FALSE.

4.%ROWCOUNT:
	- IT RETURNS NO.OF ROWS AFFECTED BY LAST DML COMMAND.

EX:
 DECLARE 
 v_EMPNO NUMBER(10);
 BEGIN
 v_EMPNO:=&v_EMPNO;
 DELETE FROM EMP WHERE EMPNO=v_EMPNO;
 IF SQL%FOUND THEN
 DBMS_OUTPUT.PUT_LINE('RECORD IS DELETED');
 ELSE
 DBMS_OUTPUT.PUT_LINE('RECORD IS NOT EXISTS');
 END IF;
 END;
 /

OUTPUT:
========
Enter value for v_empno: 7788
RECORD IS DELETED

REF. CURSORS:
============
- WHEN WE ASSIGN "SELECT STATEMENT" AT THE TIME OF OPENING CURSOR IS CALLED AS "REF.CURSOR".
- REF.CURSORS ARE TWO TYPES.THOSE ARE ,
	1. WEAK REF.CURSOR
	2. STRONG REF.CURSOR

1. WEAK REF.CURSOR:
===================
	WHEN WE DECLARE REF.CURSOR WITHOUT RETURN TYPES IS CALLED AS
WEAK REF.CURSOR.

SYNTAX:
--------------
	<CURSOR VARIABLE NAME>	SYS_REFCURSOR; ------> (IT IS PRE-DEFINE TYPE)

EX:
DECLARE
C1 SYS_REFCURSOR;
i EMP%ROWTYPE;
BEGIN
OPEN C1 FOR SELECT * FROM EMP WHERE DEPTNO=10;
LOOP
FETCH C1 INTO i;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(i.EMPNO||','||i.ENAME||','||i.SAL||','||i.DEPTNO);
END LOOP;
CLOSE C1;
END;
/

2)STRONG REF.CURSOR:
====================
	- WHEN WE DECLARE A REF. CURSOR ALONG WITH RETURN TYPE IS CALLED AS STRONG REF.CURSOR.

CREATE A USER DEFINE STRONG REF.CURSOR DATATYPE:
=================================================
SYNTAX:
--------------
	TYPE <TYPE NAME> IS REF CURSOR RETURN <TYPE>;---->(IT IS USER-DEFINE TYPE)

EX:
DECLARE 
TYPE UD_REFCURSOR IS REF CURSOR RETURN EMP%ROWTYPE;
C1 UD_REFCURSOR;
i EMP%ROWTYPE;
BEGIN
OPEN C1 FOR SELECT * FROM EMP WHERE DEPTNO=10;
LOOP
FETCH C1 INTO i;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(i.EMPNO||','||i.ENAME||','||i.SAL||','||i.DEPTNO);
END LOOP;
CLOSE C1;
END;
/

EX.OF WEAK CURSOR ON MULTIPLE TABLES:
======================================
DECLARE
C1 SYS_REFCURSOR;
i EMP%ROWTYPE;
J DEPT%ROWTYPE;
v_DEPTNO NUMBER(10):=&v_DEPTNO;
BEGIN
IF v_DEPTNO = 10 THEN
OPEN C1 FOR SELECT * FROM EMP WHERE DEPTNO=10;
LOOP
FETCH C1 INTO i;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(i.EMPNO||','||i.ENAME||','||i.SAL||','||i.DEPTNO);
END LOOP;
ELSIF  v_DEPTNO = 20 THEN
OPEN C1 FOR SELECT * FROM DEPT WHERE DEPTNO=20;
LOOP
FETCH C1 INTO J;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(J.DEPTNO||','||J.DNAME||','||J.LOC);
END LOOP;
CLOSE C1;
END IF;
END;
/

DIFF. B/W WEAK AND STRONG REF.CURSOR:
=====================================

	WEAK REF CURSOR 			STRONG REF CURSOR
	--------------------------------			-------------------------------------
1. IT IS NOT DECLARE WITH "RETURN"		1. DECLARING WITH "RETURN" TYPE
TYPE.

2. PRE-DEFINE TYPE IS AVAILABLE		2. PRE-DEFINE TYPE IS NOT AVAILABLE THATS WHY WE 
					ARE CREATING "USED DEFINE TYPE".

3. IT CAN ACCESS ROWS OF ANY 		3. IT CAN ACCESS ROWS OF 
TYPE OF TABLE(MORE THAN ONE TABLE)	 A SPECIFIC TABLE ONLY.

-----------------------------------------------------------------------------------------------------------------------------------------------
EX.OF STRONG CURSOR ON MULTIPLE TABLES:(NOT SUPPORTING)
========================================
DECLARE
TYPE UD_REFCURSOR IS REF CURSOR RETURN EMP%ROWTYPE;
C1 UD_REFCURSOR;
i EMP%ROWTYPE;
J DEPT%ROWTYPE;
v_DEPTNO NUMBER(10):=&v_DEPTNO;
BEGIN
IF v_DEPTNO = 10 THEN
OPEN C1 FOR SELECT * FROM EMP WHERE DEPTNO=10;
LOOP
FETCH C1 INTO i;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(i.EMPNO||','||i.ENAME||','||i.SAL||','||i.DEPTNO);
END LOOP;
ELSIF  v_DEPTNO = 20 THEN
OPEN C1 FOR SELECT * FROM DEPT WHERE DEPTNO=20;
LOOP
FETCH C1 INTO J;
EXIT WHEN C1%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(J.DEPTNO||','||J.DNAME||','||J.LOC);
END LOOP;
CLOSE C1;
END IF;
END;
/


   






























 
  
 
 





























7900,JAMES
7934,MILLER





















	































